#! /usr/bin/env python3


"""
COMP3311
23T1
Assignment 2
Pokemon Database

Written by: ERIC LIAO z5422235
Written on: 05/04/2023

My Pokemon

Create your very own Pokemon
"""


import sys
import psycopg2
import helpers
from random import Random


### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None


### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret

# generates a list of 10 idName objects for random pokemon games 
def getRandomGames(cur) -> list:
    query = """
    SELECT id, name
    FROM games
    ORDER BY random()
    LIMIT 10
    """
    randomGameArray = []

    cur.execute(query)
    for gameId, gameName in cur.fetchall():
        randomGameArray.append({'id': gameId, 'name': gameName})

    return randomGameArray

# given a gameId, generates 10 random pokemon which can be encountered 
# at a location which that given gameId has
def getRandomPokemon(cur, gameName: int) -> list:
    query = """
    SELECT pm.id, pm.name, pm.species, (pm.id).pokedex_number, pd.regional_id
    FROM pokemon AS pm
    INNER JOIN pokedex AS pd ON pd.national_id = pm.id
    INNER JOIN games AS g ON g.id = pd.game
    WHERE g.name = %s
    ORDER BY random()
    LIMIT 10
    """

    randomPokemonArray = []

    cur.execute(query, [gameName])
    for id, name, species, pokedexNo, regionalId in cur.fetchall():
        randomPokemonArray.append({'id': id, 'name': name, 'species': species, 'pokedexNo': pokedexNo, 'regionalId': regionalId})

    return randomPokemonArray

# for a given pokemonId returns the first type name + second type name string
# if the second type is None, then only returns the first type name string
def getSelectedPokemonTypes(cur, pokemonId) -> str:
    query = """
    SELECT t1.name, t2.name
    FROM pokemon as p
    INNER JOIN types AS t1 ON p.first_type = t1.id
    LEFT JOIN types AS t2 ON p.second_type = t2.id
    WHERE p.id = %s::pokemon_id
    """
    
    cur.execute(query, [pokemonId])
    types = cur.fetchone()

    return ' + '.join([t for t in types if t])

# given a pokemonId, returns an array of the knowable abilities' id and names
def getKnowableAbilities(cur, pokemonId) -> list:
    query = """
    SELECT DISTINCT a.id, a.name
    FROM abilities AS a
    INNER JOIN knowable_abilities AS k ON k.knows = a.id
    WHERE k.known_by = %s::pokemon_id
    ORDER BY a.id
    """

    knowableAbilities = []

    cur.execute(query, [pokemonId])
    for _, abilityName in cur.fetchall():
        knowableAbilities.append(abilityName)

    return knowableAbilities

# given a pokemonId and gameId returns an array of the all learnable moves
# for that corresponding pokemon and game that can be learnt from a level up
def getLearnableMoves(cur, pokemonId, gameId):
    query = """
    SELECT DISTINCT m.id, m.name, t.name, m.category, m.power, m.accuracy
    FROM moves AS m
    INNER JOIN learnable_moves AS l ON l.learns = m.id
    INNER JOIN types           AS t ON t.id = m.of_type
    INNER JOIN requirements    AS r ON r.id = l.learnt_when
    WHERE l.learnt_by = %s::pokemon_id 
    AND l.learnt_in = %s
    AND r.assertion ~ '^Level:'
    ORDER BY m.id
    """

    learnableMoves = []

    cur.execute(query, [pokemonId, gameId])
    for id, name, type, category, power, accuracy in cur.fetchall():
        learnableMoves.append({'id': id, 'name': name, 'type': type, 'category': category, 'power': power, 'accuracy': accuracy})

    return learnableMoves

def main():
    cur = db.cursor()
    # set the postgres random with the given sys.argv[1] seed
    cur.execute("SELECT setseed(%s);", [rng.random()])

    # get array of 10 random games from sys.argv[1] seed
    randomGames = getRandomGames(cur)
    selectedGame = menu([game['name'] for game in randomGames])
    selectedGameName = randomGames[selectedGame]['name']
    selectedGameId = randomGames[selectedGame]['id']

    # get array of 10 random pokemon from chosen game's id
    randomPokemons = getRandomPokemon(cur, selectedGameName)
    selectedPokemon = menu([pokemon['name'] for pokemon in randomPokemons])
    selectedPokemonId = randomPokemons[selectedPokemon]['id']

    # get the selected pokemon type as a string
    selectedPokemonTypes = getSelectedPokemonTypes(cur, selectedPokemonId)

    # get an array of all knowable abilities from chosen pokemon's id
    knowableAbilities = getKnowableAbilities(cur, selectedPokemonId)

    # if knowableAbilities is not empty array, prompt the user to select an ability
    if knowableAbilities:   
        selectedAbility = knowableAbilities[menu(knowableAbilities)]
    else:
        selectedAbility = 'None'

    # array that stores the 4 chosen moves
    selectedMoves = []

    learnableMoves = getLearnableMoves(cur, selectedPokemonId, selectedGameId)

    for move in range(len(learnableMoves[:4])):
        selectedMoves.append(learnableMoves.pop(menu([move['name'] for move in learnableMoves])))
    
    # printing everything out to the terminal
    print(f"Here is your new Pokemon (from Pokemon {randomGames[selectedGame]['name']}):")

    print("Name: " + randomPokemons[selectedPokemon]['name'])
    print("Species: " + randomPokemons[selectedPokemon]['species'])
    print("Type: " + selectedPokemonTypes)
    print(f"Pokedex Number: {randomPokemons[selectedPokemon]['regionalId']} ({randomPokemons[selectedPokemon]['pokedexNo']})")

    print("Ability: " + selectedAbility)

    print("Moves:")
    for move in selectedMoves:
        print(f"\t{move['name']} [{move['type']}] (Category: {move['category']}, Power: {move['power']}, Accuracy: {move['accuracy']})")


if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)
